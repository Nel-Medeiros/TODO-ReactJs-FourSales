{"version":3,"sources":["components/Todo.js","components/Form.js","components/FilterButton.js","App.js","index.js"],"names":["Todo","props","useState","setEditing","newName","setNewName","useSpring","opacity","from","id","name","pessoal","Form","setName","onSubmit","e","preventDefault","addTask","className","htmlFor","type","autoComplete","value","onChange","target","placeholder","maxLength","FilterButton","aria-pressed","isPressed","onClick","setFilter","FILTER_MAP","Tudo","Trabalho","task","Pessoal","FILTER_NAMES","Object","keys","App","tasks","setTasks","filter","editTask","editedTaskList","map","toggleTaskPessoal","updatedTasks","console","log","deleteTask","remainingTasks","taskList","key","filterList","tasksNoun","length","headingText","newTask","nanoid","role","aria-labelledby","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"6SAUe,SAASA,EAAKC,GAAQ,IAAD,EAEAC,oBAAS,GAFT,mBAEdC,GAFc,aAGFD,mBAAS,IAHP,mBAGzBE,EAHyB,KAGhBC,EAHgB,KAIpBC,YAAU,CAACC,QAAS,EAAGC,KAAM,CAACD,QAAS,KAiBNN,EAAMQ,GACxBR,EAAMS,KAGrBT,EAAMQ,GAQiB,IAAwKR,EAAMS,KAChK,IAAkIT,EAAMS,KAQ3KT,EAAMQ,GAEMR,EAAMU,QAIeV,EAAMQ,GAC1CR,EAAMS,KAIoB,IAA6JT,EAAMS,KACnK,IAAqLT,EAAMS,KC7DrN,SAASE,EAAKX,GAAQ,IAAD,EAERC,mBAAS,IAFD,mBAEzBQ,EAFyB,KAEnBG,EAFmB,KAiBhC,OACI,0BAAMC,SAPV,SAAsBC,GAClBA,EAAEC,iBACFf,EAAMgB,QAAQP,GACdG,EAAQ,MAKR,wBAAIK,UAAU,iBACZ,2BAAOC,QAAQ,iBAAiBD,UAAU,6BAA1C,mCAIF,2BACEE,KAAK,OACLX,GAAG,iBACHS,UAAU,kBACVR,KAAK,OACLW,aAAa,MACbC,MAAOZ,EACPa,SAzBN,SAAsBR,GAClBF,EAAQE,EAAES,OAAOF,QAyBfG,YAAY,yBACZC,UAAU,QAEZ,4BAAQN,KAAK,SAASF,UAAU,4BAAhC,qBCpCO,SAASS,EAAa1B,GACjC,OACI,4BACEmB,KAAK,SACLF,UAAU,iBACVU,eAAc3B,EAAM4B,UACpBC,QAAS,kBAAM7B,EAAM8B,UAAU9B,EAAMS,QAErC,0BAAMQ,UAAU,mBAAhB,UACA,8BAAOjB,EAAMS,MACb,0BAAMQ,UAAU,mBAAhB,aCHV,IAAMc,EAAa,CACjBC,KAAM,kBAAM,GACZC,SAAU,SAAAC,GAAI,OAAKA,EAAKxB,SACxByB,QAAS,SAAAD,GAAI,OAAIA,EAAKxB,UAIlB0B,EAAeC,OAAOC,KAAKP,GAwGlBQ,MArGf,SAAavC,GAAQ,IAAD,EAEQC,mBAASD,EAAMwC,OAFvB,mBAEXA,EAFW,KAEJC,EAFI,OAGUxC,mBAAS,QAHnB,mBAGXyC,EAHW,KAGHZ,EAHG,KAclB,SAASa,EAASnC,EAAIL,GAEpB,IAAMyC,EAAiBJ,EAAMK,KAAI,SAAAX,GAE/B,OAAG1B,IAAO0B,EAAK1B,GACN,eAAI0B,EAAX,CAAiBzB,KAAMN,IAElB+B,KAETO,EAASG,GAGX,SAASE,EAAkBtC,GACzB,IAAMuC,EAAeP,EAAMK,KAAI,SAAAX,GAE7B,OAAG1B,IAAO0B,EAAK1B,GAEN,eAAI0B,EAAX,CAAiBxB,SAAUwB,EAAKxB,UAE3BwB,KAETO,EAASM,GACTC,QAAQC,IAAIT,EAAM,IAGpB,SAASU,EAAW1C,GAGlB,IAAM2C,EAAiBX,EAAME,QAAO,SAAAR,GAAI,OAAI1B,IAAO0B,EAAK1B,MACxDiC,EAASU,GAGX,IAAMC,EAAWZ,EAEdE,OAAOX,EAAWW,IAClBG,KAAI,SAAAX,GAAI,OACT,kBAACnC,EAAD,CACES,GAAI0B,EAAK1B,GACTC,KAAMyB,EAAKzB,KACXC,QAASwB,EAAKxB,QACd2C,IAAKnB,EAAK1B,GACVsC,kBAAmBA,EACnBI,WAAYA,EACZP,SAAUA,OAIRW,EAAalB,EAAaS,KAAI,SAAApC,GAAI,OACtC,kBAACiB,EAAD,CACE2B,IAAK5C,EACLA,KAAMA,EACNmB,UAAWnB,IAASiC,EACpBZ,UAAWA,OAMTyB,EAAYH,EAASI,OAAS,EAAI,oBAAsB,kBACxDC,EAAW,UAAML,EAASI,OAAf,YAAyBD,GAI1C,OACE,yBAAKtC,UAAU,uBACb,gDACA,kBAACN,EAAD,CAAMK,QAzEV,SAAiBP,GACf,IAAMiD,EAAU,CAAClD,GAAI,QAAUmD,cAAUlD,KAAMA,EAAMC,SAAS,GAC9D+B,EAAS,GAAD,mBAAKD,GAAL,CAAYkB,KACpBV,QAAQC,IAAIT,MAuEV,yBAAKvB,UAAU,qCACZqC,GAEH,wBAAI9C,GAAG,gBACJiD,GAEH,oFAEA,wBACEG,KAAK,OACL3C,UAAU,wCACV4C,kBAAgB,gBAGfT,KCzGTU,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,CAAKxB,MANI,CACX,CAAEhC,GAAI,SAAUC,KAAM,kBAAmBC,SAAS,OAOlDuD,SAASC,eAAe,W","file":"static/js/main.e9be6474.chunk.js","sourcesContent":["import React, {useState} from 'react';\r\n\r\nimport {RiCloseCircleLine} from 'react-icons/ri'\r\nimport {TiEdit} from 'react-icons/ti'\r\nimport { BsCheckCircle } from 'react-icons/bs';\r\nimport { BsDashCircleFill } from 'react-icons/bs';\r\n\r\nimport {useSpring, animated} from 'react-spring'\r\n\r\n\r\nexport default function Todo(props) {\r\n\r\n    const [isEditing, setEditing] = useState(false);\r\n    const [newName, setNewName] = useState('');\r\n    const pop = useSpring({opacity: 1, from: {opacity: 0}})\r\n\r\n    function handleChange(e) {\r\n      setNewName(e.target.value);\r\n    }\r\n\r\n    function handleSubmit(e) {\r\n      e.preventDefault();\r\n      props.editTask(props.id, newName);\r\n      setNewName(\"\");\r\n      setEditing(false);\r\n    }\r\n\r\n    //criamos duas UIs diferentes, uma para a visualização padrão da tarefa e uma para a edição da tarefa\r\n    const editingTemplate = (\r\n      <form className=\"stack-small\" onSubmit={handleSubmit}>\r\n        <div className=\"form-group\">\r\n          <label className=\"todo-label\" htmlFor={props.id}>\r\n            Editando a tarefa {props.name}\r\n          </label>\r\n          <input \r\n            id={props.id} \r\n            className=\"todo-text\" \r\n            type=\"text\" \r\n            value={newName}\r\n            onChange={handleChange}\r\n          />\r\n        </div>\r\n        <div className=\"icon-group\">\r\n          <button className=\"tooltip\"><BsDashCircleFill className=\"btn-icon cancel\" onClick={() => setEditing(false)}  /><span class=\"tooltiptext\">Cancelar<span className=\"visually-hidden\">edição da tarefa {props.name}</span></span></button>          \r\n          <button className=\"tooltip\" type=\"submit\"><BsCheckCircle  className=\"btn-icon save\" /><span class=\"tooltiptext\">Confirmar<span className=\"visually-hidden\">edição da tarefa {props.name}</span></span></button>          \r\n        </div>\r\n      </form>\r\n    );\r\n    const viewTemplate = (\r\n      <div className=\"stack-small\">\r\n        <div className=\"c-cb\">          \r\n            <input\r\n              id={props.id}\r\n              type=\"checkbox\"\r\n              defaultChecked={props.pessoal}\r\n              //quando houver alteração no checkbox a prop 'toggleTaskPessoal' será acionada e receberá o 'id' da tarefa que alterou o estado do checkbox\r\n              onChange={() => props.toggleTaskPessoal(props.id)}\r\n            />\r\n            <label className=\"todo-label\" htmlFor={props.id}>\r\n              {props.name}\r\n            </label>\r\n        </div>\r\n          <div className=\"btn-group icon-group\">\r\n            <button className=\"tooltip\"><TiEdit className=\"btn-icon edit\" onClick={() => setEditing(true)}/><span class=\"tooltiptext\" style={{top: \"-30px\"}}>Editar<span className=\"visually-hidden\">{props.name}</span></span></button>            \r\n            <button className=\"tooltip\"><RiCloseCircleLine className=\"btn-icon delete\" onClick={() => props.deleteTask(props.id)}/><span class=\"tooltiptext\" style={{top: \"-30px\"}}>Remover<span className=\"visually-hidden\">{props.name}</span></span></button>            \r\n          </div>\r\n      </div>\r\n    );\r\n\r\n    return (\r\n      //utilizamos o conditional rendering do jsx para indicarmos qual UI queremos que seja exibida. se o valor de 'isEditing' for true então a UI de edição de task será exibida, do contrário a UI de visualização padrão será exibida      \r\n      <animated.div style={pop}><li className=\"todo\">{isEditing ? editingTemplate : viewTemplate}</li></animated.div>              \r\n    );\r\n}","import React, {useState} from 'react';\r\n\r\n\r\nexport default function Form(props) {\r\n\r\n    const [name, setName] = useState(\"\");\r\n\r\n    //função ativada quando o usuário digita no campo input\r\n    //essa função será usada para alterar o state 'name' que, por sua vez, é o estado responsável pelo state do input\r\n    function handleChange(e) {\r\n        setName(e.target.value)\r\n    }\r\n\r\n    //função acionada quando o usuário clica no botão 'ADD'\r\n    function handleSubmit(e) {\r\n        e.preventDefault();\r\n        props.addTask(name);\r\n        setName(\"\");\r\n    }\r\n\r\n    return(\r\n        <form onSubmit={handleSubmit}>\r\n        <h2 className=\"label-wrapper\">\r\n          <label htmlFor=\"new-todo-input\" className=\"label__lg visually-hidden\">\r\n            Insira uma nova tarefa abaixo.\r\n          </label>\r\n        </h2>\r\n        <input\r\n          type=\"text\"\r\n          id=\"new-todo-input\"\r\n          className=\"input input__lg\"\r\n          name=\"text\"\r\n          autoComplete=\"off\"\r\n          value={name}\r\n          onChange={handleChange}\r\n          placeholder=\"Insira uma nova tarefa\"\r\n          maxLength=\"100\"//limita o input à 100 caracteres\r\n        />\r\n        <button type=\"submit\" className=\"btn btn__primary btn__lg\">\r\n          Adicionar tarefa\r\n        </button>\r\n      </form>\r\n    )\r\n}","import React from 'react';\r\n\r\nexport default function FilterButton(props) {\r\n    return (\r\n        <button \r\n          type=\"button\" \r\n          className=\"btn toggle-btn\" \r\n          aria-pressed={props.isPressed}\r\n          onClick={() => props.setFilter(props.name)}\r\n        >\r\n          <span className=\"visually-hidden\">Exiba </span>\r\n          <span>{props.name}</span>\r\n          <span className=\"visually-hidden\"> tarefas</span>\r\n        </button>        \r\n    )\r\n}","import React, {useState} from 'react';\nimport {nanoid} from 'nanoid';\n\nimport Todo from './components/Todo';\nimport Form from './components/Form';\nimport FilterButton from './components/FilterButton';\n\n\n//criamos um objeto no qual cada valor é uma função. esses serão nossos filters buttons\nconst FILTER_MAP = {\n  Tudo: () => true,\n  Trabalho: task => !task.pessoal,\n  Pessoal: task => task.pessoal,\n};\n\n//criamos uma variável que coletará um array de FILTER_NAMES utilizando as keys do FILTER_MAP\nconst FILTER_NAMES = Object.keys(FILTER_MAP);\n\n\nfunction App(props) {\n\n  const [tasks, setTasks] = useState(props.tasks);\n  const [filter, setFilter] = useState('Tudo');\n\n  //a função addTask recebe um 'name', que é o input do user, monta um objeto com id, name, e pessoal, em seguida chama a função 'setTask', utiliza o spred operator para copiar o array de tasks existente e adiciona a new task nesse array.\n  //para não haver conflito de id, utilizei a lib 'nanoid' para gerar os ids das tasks\n  function addTask(name) {\n    const newTask = {id: \"todo-\" + nanoid(), name: name, pessoal: false};\n    setTasks([...tasks, newTask]);\n    console.log(tasks)\n  }\n\n  //a função editTask espera receber o id e um novo valor de name da task q a invocou. \n  function editTask(id, newName) {\n    //a variável editedTaskList usa o map para iterar pelo array de tasks executando a função que compara o id recebido pela função com o id das tasks, se houver um id que combine com o recebido então é criado um novo objeto dessa task com os mesmos atributos excetuando apenas o 'name', que rebe um novo valor. Atualizamos o estado do array de tasks utilizando a variável editedTaskList.\n    const editedTaskList = tasks.map(task => {\n      //se o id recebido combinar com algum id do array...\n      if(id === task.id) {\n        return {...task, name: newName}\n      }\n      return task;\n    })\n    setTasks(editedTaskList);\n  }\n\n  function toggleTaskPessoal(id) {\n    const updatedTasks = tasks.map(task => {\n      //se essa task tiver o mesmo id da task editada\n      if(id === task.id) {\n        //usamos o spred para criar um novo objeto 'task' no qual a prop 'pessoal' foi invertida\n        return {...task, pessoal: !task.pessoal}\n      }\n      return task;\n    });\n    setTasks(updatedTasks);\n    console.log(tasks[0])\n  }\n\n  function deleteTask(id) {\n    //console.log(id);\n    // a variável 'remainingTasks' vai receber um array de tasks, utilizando o filter, no qual o id da task que chamou a função não existe e, consequentemente, a task em si também não. Atualizamos o setTasks com essa variável.\n    const remainingTasks = tasks.filter(task => id !== task.id);\n    setTasks(remainingTasks);\n  }\n\n  const taskList = tasks\n    //ao renderizar a taskList primeiro devemos fazer um filter para que sejam exibidas apenas as tasks selecionadas pelo FILTER_MAP \n    .filter(FILTER_MAP[filter])\n    .map(task => (\n    <Todo \n      id={task.id} \n      name={task.name} \n      pessoal={task.pessoal} \n      key={task.id} \n      toggleTaskPessoal={toggleTaskPessoal}\n      deleteTask={deleteTask}\n      editTask={editTask}\n    />\n  ));\n\n  const filterList = FILTER_NAMES.map(name => (\n    <FilterButton \n      key={name} \n      name={name}\n      isPressed={name === filter}\n      setFilter={setFilter}\n    />\n  ));\n\n  //aqui criamos uma variável que conta os elementos do nosso array de tasks e recebe a string 'tasks' se o array possuir mais de 1 elemento ou a string 'task' ou a string 'task' se possuir apenas 1.\n  //e outra variável que imprime a quantidade de tasks restantes utilizando também a variável acima\n  const tasksNoun = taskList.length > 1 ? 'tarefas restantes' : 'tarefa restante';\n  const headingText = `${taskList.length} ${tasksNoun}`;\n\n  \n\n  return (\n    <div className=\"todoapp stack-large\">\n      <h1>Lista de Tarefas</h1>\n      <Form addTask={addTask} />\n      <div className=\"filters btn-group stack-exception\">\n        {filterList}\n      </div>\n      <h2 id=\"list-heading\">\n        {headingText}\n      </h2>\n      <h4>Marque a caixa de texto em caso de tarefas pessoais.</h4>\n      \n      <ul\n        role=\"list\"\n        className=\"todo-list stack-large stack-exception\"\n        aria-labelledby=\"list-heading\"\n      >  \n           \n        {taskList}  \n      </ul>      \n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nconst DATA = [\n  { id: \"todo-0\", name: \"Estudar ReactJs\", pessoal: true },\n]\n\nReactDOM.render(\n  <React.StrictMode>\n    <App tasks={DATA} />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}